#!/usr/bin/env python3

import subprocess
import time
import argparse
import sys
from typing import Callable


class WaitForDBToBeReady:
    host: str
    port: int
    user: str
    password: str
    timeout: int
    db_name: str

    def __init__(self, host: str, db_type: str, port: int = 3306, user: str = '', password: str = '', timeout: int = 15,
                 db_name: str = ''):

        self.host = host
        self.port = port
        self.user = user
        self.password = password
        self.timeout = timeout
        self.type = db_type
        self.db_name = db_name

    def _get_checker_command(self) -> Callable:
        """
        Detect which checking command fits best
        :return:
        """

        if self.type == 'mysql':
            if WaitForDBToBeReady.is_mysql_tool_available() and self.user:
                print(' >> MySQL tool checker was selected')
                return self.get_wait_command_for_mysql()

            print(' >> NC tool was selected')
            return self.get_wait_command_for_mysql_nc()

        if self.type == 'postgres':
            if WaitForDBToBeReady.is_postgres_toolkit_available():
                print(' >> PostgreSQL toolkit is available and will be used')
                return self.get_wait_command_for_pg_is_ready()

            print(' >> NC tool was selected for PostgreSQL')
            return self.get_wait_command_for_postgres_nc()

        raise Exception('Unsupported database type. Only mysql and postgres are supported.')

    def main(self):
        checker = self._get_checker_command()
        time_left = self.timeout

        while time_left != 0:
            if checker():
                print(' >> The DB seems to be online')
                sys.exit(0)

            time.sleep(1)
            time_left -= 1

        print(' >> Error: The DB is still down')
        sys.exit(1)

    def get_wait_command_for_mysql(self) -> Callable:
        return lambda: self.is_command_of_success_code(
            'mysql ' +
            '-h "' + self.host + '" ' +
            '-P "' + str(self.port) + '" ' +
            '-u"' + self.user + '" ' +
            ('-p"' + self.password + '" ' if self.password else ' ') +
            '-e "SELECT 1;"'
        )

    def get_wait_command_for_mysql_nc(self) -> Callable:
        return lambda: self.is_command_of_success_code(
            'echo "ttttt\n\n" | nc -w 1 "' + self.host + '" "' + str(self.port) + '" | grep "mysql_native"'
        )

    def get_wait_command_for_postgres_nc(self) -> Callable:
        return lambda: self.is_command_of_success_code(
            'nc -z %s %i' % (self.host, self.port)
        )

    def get_wait_command_for_pg_is_ready(self) -> Callable:
        opts = ''

        if self.db_name:
            opts += ' --dbname=%s ' % self.db_name

        if self.user:
            opts += ' --username=%s ' % self.user

        return lambda: self.is_command_of_success_code(
            'pg_isready %s --host=%s --port=%i --timeout=1' % (opts, self.host, self.port)
        )

    @staticmethod
    def is_mysql_tool_available() -> bool:
        return WaitForDBToBeReady.is_command_of_success_code('command -v mysql')

    @staticmethod
    def is_postgres_toolkit_available() -> bool:
        return WaitForDBToBeReady.is_command_of_success_code('command -v pg_isready')

    @staticmethod
    def is_command_of_success_code(cmd: str) -> bool:
        try:
            subprocess.check_output(cmd, shell=True)
            return True

        except subprocess.CalledProcessError as e:
            print(e.output.decode('utf-8'))
            return False


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--host',
                        help='IP address of unix socket',
                        required=True)
    parser.add_argument('--port',
                        help='Port (defaults to 3306)',
                        default=3306)
    parser.add_argument('--username',
                        help='Username (optional, when not specified, then only port will be checked)',
                        required=False)
    parser.add_argument('--password',
                        help='Password (optional)',
                        default='')
    parser.add_argument('--timeout',
                        help='Timeout in seconds (optional, defaults to 15)',
                        default=15)

    parser.add_argument('--type',
                        help='Database type. Possible values: postgres, mysql',
                        required=True)

    parsed = vars(parser.parse_args())

    WaitForDBToBeReady(
        host=parsed['host'],
        db_type=parsed['type'],
        port=int(parsed['port']),
        user=parsed['username'],
        password=parsed['password'],
        timeout=int(parsed['timeout'])
    ).main()
